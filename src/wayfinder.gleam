import filepath
import given
import glance
import gleam/list
import gleam/string
import justin
import simplifile
import wayfinder/project

// [ ] TODO generate path -> route
// [ ] TODO generate route -> path
// [ ] TODO generate automatic encoder for search params
// [ ] TODO validate path arguments

pub type WayfinderError {
  FileMissing
  FileReadError
  MissingRouteType
  MissingRouteInstantiation
  FileWriteError
}

pub type SearchParams =
  List(#(String, String))

pub type PathSegment {
  Literal(val: String)
  Param(name: String)
}

type RouteDefinition =
  #(glance.Variant, glance.Constant, List(PathSegment))

const autogenerated_line = "// === === === CODE BELOW IS AUTO GENERATED === === ==="

pub fn main() {
  let result = generate()
  echo result
}

pub fn generate() -> Result(Nil, WayfinderError) {
  let assert Ok(name) = project.name()
  let module_path =
    project.src()
    |> filepath.join(name)
    |> filepath.join("wayfinder.gleam")

  let code = simplifile.read(module_path)
  use code <- given.ok(code, fn(_) { Error(FileMissing) })

  let module = glance.module(code)
  use module <- given.ok(module, fn(_) { Error(FileReadError) })

  let def_route_type =
    list.find(module.custom_types, fn(t) {
      let glance.CustomType(name, _, _, _, _) = t.definition
      name == "Route"
    })

  use route_type <- given.ok(def_route_type, fn(_) { Error(MissingRouteType) })
  let glance.Definition(_, route_type) = route_type

  let routes_defs: List(RouteDefinition) =
    route_type.variants
    |> list.map(fn(v) {
      let constant =
        list.find(module.constants, fn(c) {
          let glance.Constant(name, _, _, _) = c.definition

          name == justin.snake_case(v.name) <> "_route"
        })
      case constant {
        Error(_) -> panic as { "missing const for route " <> v.name }
        Ok(constant) -> {
          let constant = constant.definition

          let path_string = case constant.value {
            glance.Call(_, args) -> {
              let assert [glance.UnlabelledField(glance.String(path)), ..] =
                args
              path
            }
            _ -> panic as { "could not extract path for route " <> v.name }
          }

          let path =
            path_string
            |> string.split("/")
            |> list.drop(1)
            |> list.map(fn(seg) {
              case seg {
                "$" <> name -> Param(name)
                name -> Literal(name)
              }
            })

          #(v, constant, path)
        }
      }
    })

  list.each(routes_defs, fn(d) { "" })

  let segs_to_route_cases =
    routes_defs
    |> list.map(fn(route) {
      //
      ""
    })
    |> list.map(fn(str) { "    " <> str })
    |> string.join("\n")

  let segs_to_route =
    "pub fn segs_to_route(segs: List(String)) -> Result(Route, Nil) {\n"
    <> "  case segs {\n"
    <> segs_to_route_cases
    <> "    _ -> Error(Nil)\n"
    <> "  }\n"
    <> "}"

  // pub fn route_to_path(route: Route) -> String {
  //   case route {
  //     Home() -> "/"
  //     Profile(id) -> "/" <> "profile/" <> id
  //   }
  // }
  let route_to_path =
    routes_defs
    |> list.map(fn(route) {
      let name = justin.snake_case({ route.0 }.name)
      let args =
        route.2
        |> list.filter(fn(seg) {
          case seg {
            Literal(_) -> False
            Param(_) -> True
          }
        })
        |> list.map(fn(arg) {
          case arg {
            Literal(_) -> ""
            Param(name) -> justin.snake_case(name)
          }
        })
        |> string.join(", ")

      let path =
        route.2
        |> list.map(fn(seg) {
          case seg {
            Literal(name) -> "\"" <> name <> "\""
            Param(name) -> justin.snake_case(name)
          }
        })
        |> string.join(" <> \"/\" <> ")

      "pub fn "
      <> name
      <> "_path("
      <> args
      <> ") {\n"
      <> "  "
      <> "\"/\" <> "
      <> path
      <> "\n}"
    })
    |> list.map(fn(str) { str })
    |> string.join("\n\n")

  let keep = case string.split(code, autogenerated_line) {
    [keep, _, ..] -> keep
    [keep] -> keep
    [] -> panic as "could not find code to keep in module"
  }
  let module_content =
    string.trim(keep)
    <> "\n\n"
    <> autogenerated_line
    <> "\n\n"
    <> segs_to_route
    <> "\n\n"
    <> route_to_path

  use _ <- given.ok(simplifile.write(module_path, module_content), fn(_) {
    Error(FileWriteError)
  })

  Ok(Nil)
}
